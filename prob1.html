<!DOCTYPE html>
<!--
Problem: 1
Language: JavaScript (with HTML and CSS)
How to use: Just open this file in a relatively modern browser!
-->
<html>
<head>
	<title>MIT PRIMES Application 2016 - Problem 1</title>
	<link rel="stylesheet" href="style.css" />
</head>
<body>
<a id="top"></a>
<header>
	<h1>MIT PRIMES Application 2016</h1>
	<h2>Problem 1</h2>
	<nav>
		Go to problem:
		<a href="index.html">index</a>
		<a href="prob1.html">1</a>
		<a href="prob2.html">2</a>
		<a href="prob3.html">3</a>
		<a href="prob4.html">4</a>
		<a href="prob5.html">5</a>
		<a href="prob6.html">6</a>
		<a href="prob7.html">7</a>
		<a href="prob8.html">8</a>
		<a href="prob9.html">9</a>
		<a href="prob10.html">10</a>
		<a href="prob11.html">11</a>
		<a href="prob12.html">12</a>
	</nav>
</header>
<article>
	<ol>
		<li>
			<blockquote>What is F<sub>8</sub>?</blockquote>
			<p>
				We can simply list out the numbers: 1, 1, 2, 3, 5, 8, 13, 21.
			F_8 = 21.
		</li>
		<li>
			This piece of code pretty much is exactly the definition, 
			except for the addition of F(0) for completeness, and returning 0 for negative n.
			
			<span class="codeblock">
				function fibonnaci(var n){
					if(n <= 0) return 0;
					else if(n <= 2) return 1;
					else return fibonnaci(n-1) + fibonnaci(n-2);
				}
				alert(fibonnaci(8));
			</span>
		</li>
		<li>
			Let N_n be the number of times the fibonnaci() function is called for an invocation of fibonnaci(n).
			N_1 and N_2 both are 1, since the function immediately returns.
			N_3 = 3, counting the call to fibonacci(3), which in turn calls fibonnaci(2) and fibonnaci(1).
			Thus, N_i = 1 + N_(i-1) + N_(i-2).
			The first few terms of N_i are 1, 1, 3, 5, 9. We're looking for N_5, so the answer is 9.

			The answer could also be obtained like this:
			<pre>
			F(5)
			 |_______________   
			 |               |
			F(4)            F(3)
			 |_______        |________
			 |       |       |        |
			F(3)    F(2)    F(2)     F(1)
			 |____ 
			 |    |
			F(2)  F(1)
			</pre>
			which also results in the same answer of 9.
		</li>
		<li>
			As the definition of N includes two previous terms of N, the number of calls grows approximately as 2^n.
			Since exponential functions get rather big rather fast, it would be quite unreasonable to compute, say, 
			a mere fibonnaci(50). It would take 53316291172 calls:
			
			<span class="codeblock">
			function getNumberOfCalls(int fibIndex){
				var N = [0, 1, 1]; //Predefine N_1 and N_2 as 1.
				for(var i = 3; i <= fibIndex; i++)
					N[i] = N[i-1] + N[i-2] + 1; //As defined in #3: N_i = 1 + N_(i-1) + N_(i-2)
				return N[fibIndex];
			}
			</span>
		</li>
	</ol>
</article>
<footer>
	<div>MIT PRIMES Application 2016</div>
	<a href="#top">Back to top</a>
</footer>
</body>
</html>
